> 1. Swift 与 Objective-C 主要区别有哪些？
> 2. Swift中 struct、class、enum 异同点
> 3. Swift中的值类型和引用类型有什么区别？各自的代表类型有哪些？如何理解值类型的Copy-on-Write机制？
> 4. inout 关键字的作用？使用时需要注意什么？
> 5. Swift中的可选类型（Optional）是什么？如何安全地解包可选类型？强制解包、可选绑定、空合并运算符的使用场景分别是什么？
> 6. 说说可选型（Optional）的底层实现


# 1. Swift 与 Objective-C 主要区别有哪些？


| 比较项      |    Swift | Objective-C  |
| :-------- | --------| :--: |
| 语言类型  | 强类型、静态类型语言，编译期检查类型错误 |  弱类型、动态类型语言，运行期才检查类型  |
| 语法简洁性  | 1.去除了OC的冗余符号（如分号、@interface/@implementation、#import） 2. 支持类型推断，无需手动声明变量类型 |     |
| 内存管理  | 1、Swift的ARC更智能，支持值类型的Copy-on-Write 2、对闭包的内存管理更清晰 3、Swift可通过weak/strong关键字更直观地处理 |     |
| 类型系统  | 值类型（struct、enum、tuple）和引用类型（class） |  OC中基本都是引用类型（除基本数据类型）  |
| 泛型支持  | Swift原生支持泛型，可定义泛型类、泛型函数、泛型协议，类型安全且代码复用性高 |  OC的泛型支持较弱（仅iOS 7+支持有限泛型，且无编译期检查） |
| 函数式编程  |  Swift支持函数式编程特性（如闭包、高阶函数map/filter/reduce），代码更简洁高效  | OC的block功能有限，函数式编程支持不足   |
| 错误处理  | Swift有完善的错误处理机制（try/catch/throw），可明确捕获和处理错误  |  OC通过NSError指针间接返回错误，错误处理不直观  |
| 安全性  | Swift去除了OC的野指针，可选类型（Optional）强制处理空值，编译期检查类型错误，减少运行时崩溃 | OC容易出现野指针、空指针错误   |
| 互操作性  |  Swift可与OC混编，但需要桥接文件（.h） |  OC无法直接调用Swift的部分特性（如泛型、值类型）  |


# 2.Swift中 struct、class、enum 异同点

1. 相同点
   > 1. 支持定义属性、方法、初始化器，也都能通过extension扩展功能、遵循并实现协议。
   > 2. 支持public/internal/private等访问控制修饰符，能限制属性 / 方法的可见性。
   > 3. 都是 Swift 的强类型，编译期会校验类型匹配，避免运行时类型错误。

2. 不同点

| 比较维度      |    struct | class  |enum  |
| :-------- | :--------| :-- |:-- |
| 类型本质  | 值类型（拷贝传递） |  引用类型（指针传递）  | 值类型（拷贝传递） | 
| 内存分配 | 栈，速度快 | 堆，引用计数管理 | 栈，速度快 |
| 继承性 | 不支持继承 | 支持单继承 | 不支持继承 |
| 标识比较 | 无（比较值是否相等） | 支持===（比较指针） | 无（比较枚举成员 / 关联值） |
| 析构函数（deinit） | 无（栈内存自动释放） | 有（堆内存释放时执行） | 无（栈内存自动释放） |
| 可变性 | 方法需mutating修饰才能修改属性 | 方法默认可修改属性 | 方法需mutating修饰才能修改关联值 / 原始值 |
| 特有特性 | 自动生成成员初始化器 | 支持析构、动态派发、单例 | 支持关联值（Associated Values）、原始值（Raw Values） |
| 使用场景 | 数据载体（如模型、工具类） | 业务逻辑对象（如控制器、管理器） | 状态/选项枚举 |


# 3. Swift中的值类型和引用类型有什么区别？各自的代表类型有哪些？如何理解值类型的Copy-on-Write机制？

1. 核心区别
   
| 比较项      |    值类型 | 引用类型  |
| :-------- | :--------| :------ |
| 存储方式 | 值类型直接存储数据本身，存储在栈中（部分复杂值类型可能存储在堆中，但访问方式仍为值语义）| 存储的是数据的内存地址（指针），数据本身存储在堆中，指针存储在栈中 |
| 赋值行为 | 值类型赋值时，会创建一个新的副本（深拷贝），修改新副本不会影响原对象 | 引用类型赋值时，仅复制指针，新对象和原对象指向同一块堆内存，修改新对象会影响原对象。 |
| 生命周期 | 值类型的生命周期与所在作用域一致，作用域结束后自动销毁  | 引用类型的生命周期由ARC管理，当没有强引用指向时，堆内存中的数据才会被销毁 |
| 线程安全 | 值类型默认是线程安全的，因为每个线程都有独立的副本 | 引用类型不是线程安全的，多线程访问同一引用类型对象可能导致数据竞争 |
| 代表类型 | struct（如Int、String、Array、Dictionary、Set）、enum（如Optional、Result）、tuple（元组） | class（如UIViewController、UIView）、closure（闭包，捕获外部变量时）、function（函数，作为参数或返回值时）。 |

2. 值类型的Copy-on-Write（写时复制）机制
   
   * 定义
        > 值类型默认在赋值时会创建副本，但为了提升性能，Swift引入了Copy-on-Write机制；当多个值类型变量指向同一块内存（只读共享）时，不会立即创建副本；只有当其中一个变量需要修改数据时，才会创建新的副本，确保修改操作不会影响其他变量。

   * 实现原理：
        > 1. 值类型内部维护一个引用计数（用于跟踪共享该内存的变量数量）
        > 2. 当变量被赋值时，引用计数加1，内存共享
        > 3. 当变量执行修改操作时，先检查引用计数：若计数为1（无其他共享），直接修改内存；若计数大于1（有其他共享），创建新的内存副本，修改副本，并将当前变量的引用指向新副本，引用计数重置为1
     
# 4. inout 关键字的作用？使用时需要注意什么？

1. 作用
   > Swift 中函数参数默认是常量（let）且采用值传递（对于值类型，函数内修改的是副本，不影响原变量），而 inout 关键字的作用是：将函数的参数标记为输入输出参数，让函数可以直接修改外部传入的变量（而非副本），修改结果会同步回原变量。

2. 底层逻辑
   > 1. 对于值类型（调用函数时 → 拷贝原变量值到函数 → 函数内修改该值 → 函数结束 → 将修改后的值拷贝回原变量）
   > 2. 对于引用类型（inout 用于修改 “引用本身”（比如让变量指向新的实例））

3. 使用时注意事项
   > 1. 使用时必须加 & 符号
   > 2. inout 参数不能有默认值
   > 3. inout 参数不能同时标记为 let/var/const
   > 4. inout 参数不能作为函数的返回值


# 5. Swift中的可选类型（Optional）是什么？如何安全地解包可选类型？强制解包、可选绑定、空合并运算符的使用场景分别是什么？

1. 可选类型
   > 1. 用于表示一个变量可能有值（任意类型），也可能没有值（nil）。Swift中默认不允许变量为nil，只有声明为可选类型的变量才能赋值为nil。
   > 2. 可选类型本质是一个枚举，定义为：enum Optional<Wrapped> { case none; case some(Wrapped) }，其中none对应nil，some对应有值的情况。
   > 3. 声明方式：在类型后加?，如var name: String? = "张三"（有值），var age: Int? = nil（无值）。

2. 安全解包可选类型的方法
   
| 比较项      |    强制解包 | 可选绑定  |
| :-------- | :--------| :------ |
| 语法 | 在可选类型变量后加! | if let/var 常量/变量 = 可选类型变量 { ... } 或 guard let/var 常量/变量 = 可选类型变量 else { ... } |
| 原理 | 直接获取可选类型中的值，若变量为nil，会触发运行时错误（崩溃） |判断可选类型是否有值，若有值则将值赋给新的常量/变量，并执行大括号内的代码；若为nil则不执行（if let）或执行else分支（guard let）|
| 使用场景|确定可选类型变量一定有值时（如已通过其他逻辑验证非nil），不推荐随意使用| if let：适用于解包后仅在当前代码块使用值的场景；guard let：适用于解包后需要在整个函数/方法中使用值的场景，可提前退出，使代码更简洁（避免嵌套）|

3. 空合并运算

* 语法
   > 可选类型变量 ?? 默认值，如let unwrappedName = name ?? "未知姓名"。

* 原理
   > 判断可选类型是否有值，若有值则返回解包后的值；若为nil则返回默认值。默认值的类型必须与可选类型的包装类型一致。

* 使用场景
  > 需要为可选类型设置默认值的场景，简洁高效，避免复杂的条件判断

4. 可选链
   
* 语法
   > 可选类型变量?.属性/方法，如let length = name?.count。

* 原理
   > 若可选类型有值，则调用属性/方法，返回结果为可选类型；若为nil，则返回nil，不会崩溃。

* 使用场景
  > 访问可选类型的属性或调用方法时，避免强制解包导致崩溃。

# 6. 说说可选型（Optional）的底层实现

可选类型的本质是 Swift 标准库中定义的一个泛型枚举（enum Optional<Wrapped>），所有带 ? 的写法（如 Int?、String?）都是这个枚举的语法糖。

1. Wrapped 是泛型参数，代表可选类型包裹的具体类型（比如 Int? 中 Wrapped 就是 Int）；
2. case none：对应 “空值”，也就是我们写的 nil；
3. case some(Wrapped)：对应 “有值”，关联值 Wrapped 存储具体的数值（比如 Int? = 10 就是 some(10)）；
4. 遵循 ExpressibleByNilLiteral 协议：这是可选类型能直接赋值 nil 的关键，该协议允许类型从 nil 字面量初始化。

```swift
@frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
    /// 表示“无值”，对应我们写的 `nil`
    case none
    
    /// 表示“有值”，关联值存储具体的类型值
    case some(Wrapped)
    
    /// 遵循 `ExpressibleByNilLiteral` 协议，让我们可以直接用 `nil` 初始化可选类型
    public init(nilLiteral: ())
}
```

