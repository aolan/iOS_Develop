> 1. Swift 与 Objective-C 主要区别有哪些？
> 2. Swift中 struct、class、enum 异同点
> 3. Swift中的值类型和引用类型有什么区别？各自的代表类型有哪些？如何理解值类型的Copy-on-Write机制？
> 4. inout 关键字的作用？使用时需要注意什么？
> 5. Swift中的可选类型（Optional）是什么？如何安全地解包可选类型？强制解包、可选绑定、空合并运算符的使用场景分别是什么？
> 6. 说说可选型（Optional）的底层实现
> 7. Swift中的协议（Protocol）与OC中的协议有什么不同？关联类型（Associated Type）的作用是什么？
> 8. Any 和 AnyObject 的区别？使用时需要注意什么？
> 9. 什么是逃逸闭包和非闭包？
> 10. unowned self 和 weak self 的核心区别
> 11. 解释 Swift 中的计算属性和存储属性？计算属性能否设置let？
> 12. 说说Swift中的访问控制


# 1. Swift 与 Objective-C 主要区别有哪些？


| 比较项      |    Swift | Objective-C  |
| :-------- | --------| :--: |
| 语言类型  | 强类型、静态类型语言，编译期检查类型错误 |  弱类型、动态类型语言，运行期才检查类型  |
| 语法简洁性  | 1.去除了OC的冗余符号（如分号、@interface/@implementation、#import） 2. 支持类型推断，无需手动声明变量类型 |     |
| 内存管理  | 1、Swift的ARC更智能，支持值类型的Copy-on-Write 2、对闭包的内存管理更清晰 3、Swift可通过weak/strong关键字更直观地处理 |     |
| 类型系统  | 值类型（struct、enum、tuple）和引用类型（class） |  OC中基本都是引用类型（除基本数据类型）  |
| 泛型支持  | Swift原生支持泛型，可定义泛型类、泛型函数、泛型协议，类型安全且代码复用性高 |  OC的泛型支持较弱（仅iOS 7+支持有限泛型，且无编译期检查） |
| 函数式编程  |  Swift支持函数式编程特性（如闭包、高阶函数map/filter/reduce），代码更简洁高效  | OC的block功能有限，函数式编程支持不足   |
| 错误处理  | Swift有完善的错误处理机制（try/catch/throw），可明确捕获和处理错误  |  OC通过NSError指针间接返回错误，错误处理不直观  |
| 安全性  | Swift去除了OC的野指针，可选类型（Optional）强制处理空值，编译期检查类型错误，减少运行时崩溃 | OC容易出现野指针、空指针错误   |
| 互操作性  |  Swift可与OC混编，但需要桥接文件（.h） |  OC无法直接调用Swift的部分特性（如泛型、值类型）  |


# 2.Swift中 struct、class、enum 异同点

1. 相同点
   > 1. 支持定义属性、方法、初始化器，也都能通过extension扩展功能、遵循并实现协议。
   > 2. 支持public/internal/private等访问控制修饰符，能限制属性 / 方法的可见性。
   > 3. 都是 Swift 的强类型，编译期会校验类型匹配，避免运行时类型错误。

2. 不同点

| 比较维度      |    struct | class  |enum  |
| :-------- | :--------| :-- |:-- |
| 类型本质  | 值类型（拷贝传递） |  引用类型（指针传递）  | 值类型（拷贝传递） | 
| 内存分配 | 栈，速度快 | 堆，引用计数管理 | 栈，速度快 |
| 继承性 | 不支持继承 | 支持单继承 | 不支持继承 |
| 标识比较 | 无（比较值是否相等） | 支持===（比较指针） | 无（比较枚举成员 / 关联值） |
| 析构函数（deinit） | 无（栈内存自动释放） | 有（堆内存释放时执行） | 无（栈内存自动释放） |
| 可变性 | 方法需mutating修饰才能修改属性 | 方法默认可修改属性 | 方法需mutating修饰才能修改关联值 / 原始值 |
| 特有特性 | 自动生成成员初始化器 | 支持析构、动态派发、单例 | 支持关联值（Associated Values）、原始值（Raw Values） |
| 使用场景 | 数据载体（如模型、工具类） | 业务逻辑对象（如控制器、管理器） | 状态/选项枚举 |


# 3. Swift中的值类型和引用类型有什么区别？各自的代表类型有哪些？如何理解值类型的Copy-on-Write机制？

1. 核心区别
   
| 比较项      |    值类型 | 引用类型  |
| :-------- | :--------| :------ |
| 存储方式 | 值类型直接存储数据本身，存储在栈中（部分复杂值类型可能存储在堆中，但访问方式仍为值语义）| 存储的是数据的内存地址（指针），数据本身存储在堆中，指针存储在栈中 |
| 赋值行为 | 值类型赋值时，会创建一个新的副本（深拷贝），修改新副本不会影响原对象 | 引用类型赋值时，仅复制指针，新对象和原对象指向同一块堆内存，修改新对象会影响原对象。 |
| 生命周期 | 值类型的生命周期与所在作用域一致，作用域结束后自动销毁  | 引用类型的生命周期由ARC管理，当没有强引用指向时，堆内存中的数据才会被销毁 |
| 线程安全 | 值类型默认是线程安全的，因为每个线程都有独立的副本 | 引用类型不是线程安全的，多线程访问同一引用类型对象可能导致数据竞争 |
| 代表类型 | struct（如Int、String、Array、Dictionary、Set）、enum（如Optional、Result）、tuple（元组） | class（如UIViewController、UIView）、closure（闭包，捕获外部变量时）、function（函数，作为参数或返回值时）。 |

2. 值类型的Copy-on-Write（写时复制）机制
   
   * 定义
        > 值类型默认在赋值时会创建副本，但为了提升性能，Swift引入了Copy-on-Write机制；当多个值类型变量指向同一块内存（只读共享）时，不会立即创建副本；只有当其中一个变量需要修改数据时，才会创建新的副本，确保修改操作不会影响其他变量。

   * 实现原理：
        > 1. 值类型内部维护一个引用计数（用于跟踪共享该内存的变量数量）
        > 2. 当变量被赋值时，引用计数加1，内存共享
        > 3. 当变量执行修改操作时，先检查引用计数：若计数为1（无其他共享），直接修改内存；若计数大于1（有其他共享），创建新的内存副本，修改副本，并将当前变量的引用指向新副本，引用计数重置为1
     
# 4. inout 关键字的作用？使用时需要注意什么？

1. 作用
   > Swift 中函数参数默认是常量（let）且采用值传递（对于值类型，函数内修改的是副本，不影响原变量），而 inout 关键字的作用是：将函数的参数标记为输入输出参数，让函数可以直接修改外部传入的变量（而非副本），修改结果会同步回原变量。

2. 底层逻辑
   > 1. 对于值类型（调用函数时 → 拷贝原变量值到函数 → 函数内修改该值 → 函数结束 → 将修改后的值拷贝回原变量）
   > 2. 对于引用类型（inout 用于修改 “引用本身”（比如让变量指向新的实例））

3. 使用时注意事项
   > 1. 使用时必须加 & 符号
   > 2. inout 参数不能有默认值
   > 3. inout 参数不能同时标记为 let/var/const
   > 4. inout 参数不能作为函数的返回值


# 5. Swift中的可选类型（Optional）是什么？如何安全地解包可选类型？强制解包、可选绑定、空合并运算符的使用场景分别是什么？

1. 可选类型
   > 1. 用于表示一个变量可能有值（任意类型），也可能没有值（nil）。Swift中默认不允许变量为nil，只有声明为可选类型的变量才能赋值为nil。
   > 2. 可选类型本质是一个枚举，定义为：enum Optional<Wrapped> { case none; case some(Wrapped) }，其中none对应nil，some对应有值的情况。
   > 3. 声明方式：在类型后加?，如var name: String? = "张三"（有值），var age: Int? = nil（无值）。

2. 安全解包可选类型的方法
   
| 比较项      |    强制解包 | 可选绑定  |
| :-------- | :--------| :------ |
| 语法 | 在可选类型变量后加! | if let/var 常量/变量 = 可选类型变量 { ... } 或 guard let/var 常量/变量 = 可选类型变量 else { ... } |
| 原理 | 直接获取可选类型中的值，若变量为nil，会触发运行时错误（崩溃） |判断可选类型是否有值，若有值则将值赋给新的常量/变量，并执行大括号内的代码；若为nil则不执行（if let）或执行else分支（guard let）|
| 使用场景|确定可选类型变量一定有值时（如已通过其他逻辑验证非nil），不推荐随意使用| if let：适用于解包后仅在当前代码块使用值的场景；guard let：适用于解包后需要在整个函数/方法中使用值的场景，可提前退出，使代码更简洁（避免嵌套）|

3. 空合并运算

* 语法
   > 可选类型变量 ?? 默认值，如let unwrappedName = name ?? "未知姓名"。

* 原理
   > 判断可选类型是否有值，若有值则返回解包后的值；若为nil则返回默认值。默认值的类型必须与可选类型的包装类型一致。

* 使用场景
  > 需要为可选类型设置默认值的场景，简洁高效，避免复杂的条件判断

4. 可选链
   
* 语法
   > 可选类型变量?.属性/方法，如let length = name?.count。

* 原理
   > 若可选类型有值，则调用属性/方法，返回结果为可选类型；若为nil，则返回nil，不会崩溃。

* 使用场景
  > 访问可选类型的属性或调用方法时，避免强制解包导致崩溃。

# 6. 说说可选型（Optional）的底层实现

可选类型的本质是 Swift 标准库中定义的一个泛型枚举（enum Optional<Wrapped>），所有带 ? 的写法（如 Int?、String?）都是这个枚举的语法糖。

1. Wrapped 是泛型参数，代表可选类型包裹的具体类型（比如 Int? 中 Wrapped 就是 Int）；
2. case none：对应 “空值”，也就是我们写的 nil；
3. case some(Wrapped)：对应 “有值”，关联值 Wrapped 存储具体的数值（比如 Int? = 10 就是 some(10)）；
4. 遵循 ExpressibleByNilLiteral 协议：这是可选类型能直接赋值 nil 的关键，该协议允许类型从 nil 字面量初始化。

```swift
@frozen public enum Optional<Wrapped> : ExpressibleByNilLiteral {
    /// 表示“无值”，对应我们写的 `nil`
    case none
    
    /// 表示“有值”，关联值存储具体的类型值
    case some(Wrapped)
    
    /// 遵循 `ExpressibleByNilLiteral` 协议，让我们可以直接用 `nil` 初始化可选类型
    public init(nilLiteral: ())
}
```

# 7. Swift中的协议（Protocol）与OC中的协议有什么不同？关联类型（Associated Type）的作用是什么？

1. 相同点
   > 可继承多个协议

2. 不同点
   
| 比较项      |    Swift协议 | OC协议  |
| :-------- | :--------| :------ |
| 适用类型 | Swift的协议可被class、struct、enum遵循（值类型和引用类型均可）| OC的协议只能被class遵循（仅引用类型）|
| 泛型支持 | Swift的协议支持关联类型（Associated Type），实现泛型协议 | OC的协议不支持泛型，仅支持有限的类型约束（iOS 7+）|
| 协议扩展 | Swift的协议可通过扩展（Extension）提供默认实现，遵循协议的类型可选择重写或直接使用默认实现| OC的协议仅声明方法，无默认实现，必须由遵循者实现|
| 可选方法| Swift的协议中，方法默认是必须实现的；若要声明可选方法，需在协议前加@objc，且只能被class遵循（兼容OC）| OC的协议中，方法可通过@optional声明为可选，@required声明为必须（默认）|
| 类型约束 | Swift的协议可通过where子句添加关联类型约束，实现更灵活的泛型逻辑 | OC的协议无此功能|
| 关联类型|Swift的协议支持关联类型|OC不支持|

3. 关联类型作用
   > 1. 关联类型：是Swift协议中用于定义泛型类型的占位符，允许协议在不指定具体类型的情况下，引用一个或多个类型，由遵循协议的类型指定具体的类型。通过associatedtype关键字声明。
   > 2. 作用：使协议支持泛型，提升协议的灵活性和复用性，让协议可以适用于多种不同的类型，而无需为每种类型单独定义协议。
   
# 8. Any 和 AnyObject 的区别？使用时需要注意什么？

1. 区别
   
| 比较项      |    Any | AnyObject  |
| :-------- | :--------| :------ |
| 适用类型 | 可以表示任意类型（包括值类型、引用类型、函数类型、可选类型等） | 仅能表示类的实例（引用类型），即继承自 NSObject 的类或纯 Swift 类 | 
| 底层本质 | Swift 原生的 “万能类型” | 对应 Objective-C 的 id 类型，是类对象的 “万能指针” |
| 常见使用场景| 处理不同类型混合的集合（如同时包含 Int、String、数组）| 与 Objective-C 交互（如 Cocoa 框架 API）、仅需限制为类实例的场景|

2. 使用时注意事项
   > * 优先避免使用，尽量指定具体类型
   > * 类型转换时必须做安全检查

# 9. 什么是逃逸闭包和非闭包？
> 核心判断依据：闭包是否在函数返回后才执行。若闭包执行时机晚于函数返回（即 “逃离” 了函数的作用域），则为逃逸闭包；若闭包在函数内部同步执行、执行完函数才返回，则为非逃逸闭包。

| 比较项      |    非逃逸闭包 | 逃逸闭包  |
| :-------- | :--------| :------ |
| 定义 | 闭包在函数体内部同步执行，函数返回前闭包已执行完毕，不会 “逃离” 函数的作用域。| 闭包在函数返回后才执行，“逃离” 了函数的作用域（如被存储在函数外部变量、用于异步任务）。|
| 语法 | 无需额外关键字，Swift 3.0+ 中闭包作为函数参数时默认是非逃逸的。|必须显式添加 @escaping 关键字声明，否则编译器报错。|
| 优势|编译器可优化内存（如分配在栈上，无需堆内存分配），且默认不会导致循环引用（因闭包生命周期短于函数，函数返回后闭包即销毁）。| 逃逸闭包若捕获外部引用类型（如 self），容易导致循环引用，需通过 [weak self]/[unowned self] 处理。|


# 10. unowned self 和 weak self 的核心区别

1. 相同点
   > * 两者均用于 Swift 闭包中解决循环引用，核心差异在于引用对象被释放后的行为以及适用场景，本质是对被引用对象生命周期的信任程度不同。
   > * 不增加引用计数

| 比较项      |    unowned self | weak self  |
| :-------- | :--------| :------ |
| 差别| 假设 self 会 “永远存在” 于闭包执行期间，对象释放后引用不会置为 nil。|当 self 被释放后，weak self 会自动变为 nil，避免野指针访问。|
| 使用场景|明确 self 的生命周期必然长于闭包（即闭包执行时，self 一定未被释放），常见于 “父子关系” 中父对象持有子对象闭包的场景（如类的初始化闭包、委托对象生命周期明确长于闭包）|闭包的生命周期可能长于 self，或无法确定 self 与闭包的生命周期先后（如网络请求回调、延迟执行的闭包）。|

# 11. 解释 Swift 中的计算属性和存储属性？计算属性能否设置let？
1. 区别

| 比较项      |    存储属性 | 计算属性  |
| :-------- | :--------| :------ |
|本质|直接存储值，占用实例内存|不存储值，仅提供 getter/setter 方法（通过计算返回值），不占用实例内存|
| 语法 |直接声明变量 / 常量（var/let）|通过 get/set 块定义|
| 可变性|let：不可变；var：可变|仅能通过 var 声明（即使只有 get；get必须实现，set 可选实现）|
|使用类型|类、结构体、枚举（枚举需关联值）|类、结构体、枚举|
|示例|var age: Int = 18|var fullName: String { get { "\(first) \(last)" } }|

2. 计算属性不能使用 let
3. 懒加载存储属性 和 只读计算属性

```Swift
struct Test {
    var num: Int = 0
    
    // 懒加载存储属性：仅计算一次
    lazy var lazyValue: Int = {
        print("懒加载计算")
        return num * 2
    }()
    
    // 计算属性：每次访问都计算
    var computedValue: Int {
        print("计算属性计算")
        return num * 2
    }
}

var t = Test(num: 1)
print(t.lazyValue) // 输出：懒加载计算 → 2（首次计算并存储）
print(t.lazyValue) // 输出：2（直接取存储值，不计算）

t.num = 2
print(t.computedValue) // 输出：计算属性计算 → 4（重新计算）
print(t.lazyValue) // 输出：2（存储值未变）
```

# 12. 说说Swift中的访问控制
> Swift 的访问控制核心是限制代码实体的访问范围，目的是隐藏内部实现细节、保护数据安全，同时明确对外接口，遵循 “最小权限原则”（为实体设置最小必要访问级别）。

| 访问控制关键字      |    描述 |
| :-------- | :--------|
| open | 定义模块内任意访问；允许其他模块继承（类）或重写（方法 / 属性）；仅支持类和类的成员（结构体、枚举不支持）|
| public| 定义模块内任意访问；允许其他模块访问，当前模块可继承，但禁止外部继承 / 重写|
|internal（默认） | 仅定义模块内访问（如 APP Target 内部、框架内部），外部模块无法访问|
|fileprivate|仅定义所在的单个.swift 文件内访问，同一模块的其他文件无法访问|
| private|仅定义所在的 “声明范围” 内访问（如类内部、函数内部、代码块内部）|
