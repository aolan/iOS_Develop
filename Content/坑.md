# 获取gateway的坑

如果你想获取iPhone连接的wifi的gateway地址，那么恭喜你，坑来了，倒不是说这个是苹果的bug，是网络上人云亦云的误导。

## 1、获取 gateway IP 地址

网络上基本都是这样写的：

```objective-c

/// NetworkHelper.h

/// 蜂窝网络的IP地址
#define IOS_CELLULAR    @"pdp_ip0"
/// WIFI的IP地址
#define IOS_WIFI        @"en0"
/// VPN地址
#define IOS_VPN         @"utun0"
/// ipv4和ipv6
#define IP_ADDR_IPv4    @"ipv4"
#define IP_ADDR_IPv6    @"ipv6"

@interface NetworkHelper : NSObject

/**
 获取ipv4网关地址
 */
+ (NSDictionary *)getGatewayIPV4Addresses;

/**
 获取ipv6网关地址
 */
+ (NSDictionary *)getGatewayIPV6Addresses;


```


```objective-c
+ (NSDictionary *)getGatewayIPV4Addresses
{
    NSMutableDictionary *addresses = [NSMutableDictionary dictionary];

    /* net.route.0.inet.flags.gateway */
    int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET, NET_RT_FLAGS, RTF_GATEWAY};
    
    size_t l;
    char *buf, *p;
    struct rt_msghdr *rt;
    struct sockaddr *sa;
    struct sockaddr *sa_tab[RTAX_MAX];
    int i;
    
    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {
        return nil;
    }
    
    if (l > 0) {
        buf = malloc(l);
        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &l, 0, 0) < 0) {
            return nil;
        }
        
        for (p = buf; p < buf + l; p += rt->rtm_msglen) {
            rt = (struct rt_msghdr *)p;
            sa = (struct sockaddr *)(rt + 1);
            for (i = 0; i < RTAX_MAX; i++) {
                if (rt->rtm_addrs & (1 << i)) {
                    sa_tab[i] = sa;
                    sa = (struct sockaddr *)((char *)sa + ROUNDUP(sa->sa_len));
                } else {
                    sa_tab[i] = NULL;
                }
            }
            
            if (((rt->rtm_addrs & (RTA_DST | RTA_GATEWAY)) == (RTA_DST | RTA_GATEWAY)) &&
                sa_tab[RTAX_DST]->sa_family == AF_INET &&
                sa_tab[RTAX_GATEWAY]->sa_family == AF_INET) {
                unsigned char octet[4] = {0, 0, 0, 0};
                int i;
                for (i = 0; i < 4; i++) {
                    octet[i] = (((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr >>
                                (i * 8)) &
                    0xFF;
                }
                if (((struct sockaddr_in *)sa_tab[RTAX_DST])->sin_addr.s_addr == 0) {
                    in_addr_t addr = ((struct sockaddr_in *)(sa_tab[RTAX_GATEWAY]))->sin_addr.s_addr;
                    NSString *address = [self p_formatIPV4Address:*((struct in_addr *)&addr)];
                    if (address.length) {
                        char ifName[128];
                        if_indextoname(rt->rtm_index, ifName);
                        NSString *key = [NSString stringWithFormat:@"%s/%@", ifName, IP_ADDR_IPv4];
                        addresses[key] = address;
                    }
                }
            }
        }
        free(buf);
    }
    return addresses;
}

+ (NSDictionary *)getGatewayIPV6Addresses
{
    NSMutableDictionary *addresses = [NSMutableDictionary dictionary];

    /* net.route.0.inet.flags.gateway */
    int mib[] = {CTL_NET, PF_ROUTE, 0, AF_INET6, NET_RT_FLAGS, RTF_GATEWAY};
    
    size_t l;
    char *buf, *p;
    struct rt_msghdr *rt;
    struct sockaddr_in6 *sa;
    struct sockaddr_in6 *sa_tab[RTAX_MAX];
    int i;
    
    if (sysctl(mib, sizeof(mib) / sizeof(int), 0, &l, 0, 0) < 0) {
        return nil;
    }
    
    if (l > 0) {
        buf = malloc(l);
        if (sysctl(mib, sizeof(mib) / sizeof(int), buf, &l, 0, 0) < 0) {
            return nil;
        }
        
        for (p = buf; p < buf + l; p += rt->rtm_msglen) {
            rt = (struct rt_msghdr *)p;
            sa = (struct sockaddr_in6 *)(rt + 1);
            for (i = 0; i < RTAX_MAX; i++) {
                if (rt->rtm_addrs & (1 << i)) {
                    sa_tab[i] = sa;
                    sa = (struct sockaddr_in6 *)((char *)sa + sa->sin6_len);
                } else {
                    sa_tab[i] = NULL;
                }
            }
            
            if( ((rt->rtm_addrs & (RTA_DST|RTA_GATEWAY)) == (RTA_DST|RTA_GATEWAY))
               && sa_tab[RTAX_DST]->sin6_family == AF_INET6
               && sa_tab[RTAX_GATEWAY]->sin6_family == AF_INET6) {
                    NSString *address = [self p_formatIPV6Address:((struct sockaddr_in6 *)(sa_tab[RTAX_GATEWAY]))->sin6_addr];
                    if (address.length) {
                        char ifName[128];
                        if_indextoname(rt->rtm_index, ifName);
                        NSString *key = [NSString stringWithFormat:@"%s/%@", ifName, IP_ADDR_IPv6];
                        addresses[key] = address;
                    }
                }
        }
        free(buf);
    }
    
    return addresses;
}

+ (NSString *)p_formatIPV4Address:(struct in_addr)ipv4Addr{
    NSString *address = nil;
    char dstStr[INET_ADDRSTRLEN];
    char srcStr[INET_ADDRSTRLEN];
    memcpy(srcStr, &ipv4Addr, sizeof(struct in_addr));
    if(inet_ntop(AF_INET, srcStr, dstStr, INET_ADDRSTRLEN) != NULL){
        address = [NSString stringWithUTF8String:dstStr];
    }
    return address;
}

+ (NSString *)p_formatIPV6Address:(struct in6_addr)ipv6Addr{
    NSString *address = nil;
    char dstStr[INET6_ADDRSTRLEN];
    char srcStr[INET6_ADDRSTRLEN];
    memcpy(srcStr, &ipv6Addr, sizeof(struct in6_addr));
    if(inet_ntop(AF_INET6, srcStr, dstStr, INET6_ADDRSTRLEN) != NULL){
        address = [NSString stringWithUTF8String:dstStr];
    }
    return address;
}

```

然后让你去取en0，说en0就是WIFI网卡连接的gateway地址。我之前也是深信不疑，知道我发现某些手机是en2，我特么知道，错了，离谱了！！！

一顿搜索，发现这个链接：https://developer.apple.com/forums/thread/724299

意思是我们不能通过指定 interface name 来确定WIFI网卡，en0只是行业内的约定俗成，并非标准，应该通过 NWPathMonitor 来获取 WIFI 对应的 interface name，然后再调用上面的方法获取 gateway 地址。操蛋了不是么，NWPathMonitor 从iOS12开始支持。




# 无线数据权限的坑

从iOS10开始，国内增加了特供功能，在使用用户的WIFI和蜂窝网络时，需要申请相应的权限，然而该权限的申请并未提供给开发者。
开发者只能调用某个接口，来触发该权限弹框的弹出。因此引入了一个巨坑，该权限弹框并不是总能文档的弹出，导致随机的应用无法访问网络。遇到这种情况怎么办？

## 1、 应用启动时检查蜂窝网络权限

```swift
    func syncCheckCellularPermission() -> Bool {
        var havePermission = false
        let semaphore = DispatchSemaphore(value: 0)
        let cellularData = CTCellularData()
        cellularData.cellularDataRestrictionDidUpdateNotifier = { state in
            havePermission = state == .notRestricted
            semaphore.signal()
        }
        semaphore.wait()
        cellularData.cellularDataRestrictionDidUpdateNotifier = nil
        // 没有权限，只是弹框引导用户去设置页面
        if !havePermission {
            DispatchQueue.main.async {
                // TODO: 弹窗提醒
            }
        }
        return havePermission
    }
```

## 2、 坑来了

在某些情况下，应用检测出没有权限，弹框提醒用户去授权无线数据权限，等用户跳转到应用权限设置页面，却没有无线数据这一项。
![image](https://github.com/aolan/iOS_Develop/assets/6744261/b9b20342-d45f-4474-809b-7eb6fc3d2320)

从网上搜索的信息来看，应用开发者无法解决这个问题，只能通过提示用户该怎么操作，恢复出无线数据这一项。

* 方法一：【设置】-【蜂窝网络】-【无线局域网助理】打开，然后重启应用，我没有尝试过，不知道能不能行，因为我们还没遇到过这种情况

* 方法二：【设置】-【通用】-【传输或还原iPhone】-【还原】-【还原网络设置】，执行这步操作，所有用到无线数据的应用会重新申请无线数据权限，
但同时带来的副作用是，所用使用了无线数据的应用，都要重新授权【无线数据】权限。

       
        
